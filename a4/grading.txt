Grading Rubric for Assignment 4

Basic Operation (50 points)
---------------------------

Test the basic operation of the system works by having two windows open.

In the first window, ssh to `student10.cse.nd.edu` and run the server:

```
python HashTableServer.py 0
(port number should be printed out)
```

In the second window, ssh to `student11.cse.nd.edu` (note different machine) and run the client:

```
python TestBasics.py <host> <port>
```

This should result in the client performing basic operations
and emitting some output indicating that it connected and worked.

**This is the key test of the code implementation quality.**
Control-C the server and restart it.  You should be able
to run the client a second time without trouble.  And, you should
be able to see some data in sheet.ckpt and sheet.log.
(OK if these files have slightly different names.)
If this sequence of events does not work, deduct 10-40 points
depending upon how much is working.

Deduct 5 points if the program does not implement the "use any port" feature,
and you have to specify a specific port to the server.

Server Code Details (20 points)
-------------------------------

Take a brief look at HashTable.py and look for the following:
+5 - Modifications should write to the transaction log.
+5 - and updates should use f.flush() and os.fsync() to force it to disk.
+5 - The checkpoint file should be periodically written and use rename() to ensure an atomic update.
+5 - The checkpoint and transaction log should be read from disk at startup.

Additional code related to the checkpoint and transaction log rebuild + file verification is permitted. make
sure this code exists somewhere and appears functional. e.g. no obvious potential for inconsistency without a failure occuring. 

Make sure the server is doing some sanitation on the filename keys provided by insert(). We don't want the server allowing someone to do:
insert('~/.bashrc', '#!/bin/bash\n curl -o ... ; ...') 

Client Code Details (10 points)
-------------------------------

+ 5 points - Take a brief look at TestBasics.py to make sure that each kind of operation has been tested (insert, lookup, remove, size, query) for success, and also that two read operations (lookup, query) have been
tested for the failure case.  (It doesn't matter whether those operations return a KeyError or a null value, as long as they have some way of indicating failure.)

The test should verify that v == lookup(x) after insert(x, v). It is optional at this point to verify the actual file on disk is the same since they would have to make a subprocess to remove the file in between, or modify the api to write explicit different file names and we want to maintain consistency with the api.  

+ 5 points - Take a brief look at TestPerf.py to make sure the measurement technique makes sense.  They should be using time.time_ns() or gettimeofday() or something similar to make a subsecond measurement of a large number of successful operations.

Comparing HashTableClient.py from the previous assignment there may be little change except for a modification to the messaging format to include metadata, as well
as general restructuring. 

Report (20 points)
------------------

+ 10 points - Examples: Must contain message format examples for a request, repsonse, and failure, for each of the insert, lookup, remove, size and query operations. Instead of file bytes the value should be some kind of serializable message containing additional info.

+ 5 points - Performance: Here is the observed performance on my solution, between student10 and student11:

insert:  xput 2141.547347282847 ops/s, latency 0.0004669520854949951s
lookup:  xput 5128.928041243669 ops/s, latency 0.00019497251510620117s
query:   xput 158.56314249521435 ops/s, latency 0.006306635856628418s
remove:  xput 5196.758765952174 ops/s, latency 0.0001924276351928711s

Throughput will likely vary quite a bit with different implementations and file sizes being transmitted. Insert and lookup
measurements may include disk I/O. I think any reasonable throughput is acceptable. 

Exceptionally slow results, or cases where there is a large discrepancy between insert and lookup should be scrutinized.

Exceptionally fast results may have been run with two local processes which is not what the assignment specified.

Query, size, and remove should be quite uniform and a good deal faster than insert and lookup. 

+ 5 points Significance: A good discussion of the significance should observe that the time to insert/lookup/remove/query is much higher than the code of a trivial function call (or dictionary operation) b/c of the necessity of a network round trip.

Finally, create a file called `GRADE` alongside the student's code that
gives the overall grade breakdown, and specific comments and deductions
in each section.  Here is an example:

-------------------------------
Example Grade File Template:
------------------------------


Assignment 4 - Persistence

Basic Operation (40 points)
---------------------------
-5 Basic configuration works fine, however, the server doesn't choose a port automatically when zero is given.

Server Code Details (20 points)
-------------------------------
-5 Overall server structure is correct, however, you should catch exceptions when the client disconnects.

Client Code Details (20 points)
-------------------------------
TestBasics.py tests all of the essential operations correctly.

-5 TestPerf.py is doing the right work, but has a print statement in the inner loop, which throws off the performance.

Report (20 points)
------------------
-5 Nice examples of the JSON messages, and your general discussion is correct.  However, note that your performance is even slower than expected, due to the extra output message.  Please remove those for the next assignment.

Total: 80
